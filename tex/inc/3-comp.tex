\section{Исследование эффективности разработанного программного обеспечения}

В главе производится сравнение параллельной и последовательной программ реализующих,
рассматриваемый в данной работе, спектрально-разностный метод.
Приводятся результаты исследований параллельной программы сгенированной системой LuNA.
Также представленно сравнение времени работы программ реализующих спектрально-разностный алгоритм
и конечно-разностную схему Верье.

\subsection{Сравнение времени работы последовательной и параллельной реализаций}

Время работы спектрально-разностного алгоритма, при фиксированных физических параметрах среды и временном интервале,
зависит от 2 параметров: от размера сетки по $z$ кординате и от количества рассматриваемых гармоник.

Если положить, что количество узлов по $z$ координате равно $N$, а количество рассматриваемых гармоник равно $K$,
то ассимпточеская оценка времени работы последовательного алгоритма составит $O(N\cdot K^2 \cdot log(K))$ для $K=2^p$. Однако на реальных численных задачах
количество гармоник $K \ll N$, это означает, что сложность алгоритма в среднем составит $O(N \cdot const)=O(N)$.

Если рассмотреть идеальную систему с $T$ физическими вычислительными ядрами, то при достаточно большой значении $N$,
ожидаемое ускорение согласно Закону Амдала не превзойдет величины $S = \frac{1}{\frac{T}{N} + \frac{1-\frac{T}{N}}{T}}$

Для эксперимента была взята система с 8 физическими ядрами($T=8$), значения сетки по $z$ варьировались от $2^8$ до $2^{16}$.
Также для того, чтобы показать, что ассимтотическая оценка сложности может быть показательной для оценки сложности алгоритма,
варьировалось число рассматриваемых гармоник (рис. \ref{perf-3-log}).

\addimghere{perf-3-log}{0.75}{Сравнение последовательной и параллельной реализации}{perf-3-log}

В результате распараллеливания удается добиться прироста производительности примерно в 6-7 раз. Тогда как
ожидаемое значение $S$ по закону Амдала составляет 7,5-8 для рассматриваемых сеток. Также из графиков видно, что прирост
производительности для различных значений K(числа рассматриваемых в эксперименте гармоник) не изменяется.

Другим интересным результатом является то, что при достаточно большом количестве рассматриваемых гармоник
наиболее эффективный результат дает комбинация Intel MKL и OpenMP (рис. \ref{mkl-final-k}).

Из графика (рис. \ref{mkl-final-k}) видно, что при количестве гармоник большем чем 128, использование библиотеки Intel MKL
дает выйгрыш производительности, тогда как при относительно маленьком числе гармоник(порядка 32), наблюдается существенное замедление.

\addimghere{mkl-final-k}{0.75}{Сравнение параллельных реализаций с/без использования Intel MKL}{mkl-final-k}

Отдельный интерес представляет тест масштабируемости параллельной реализации с использованием OpenMP (рис. \ref{perf-threads}).
Он показывает, что величина $T(1)/T(N)$, где $T(N)$ - время работы программы для $N$ потоков, а $T(1)$ - время ее последовательного исполнения, растет с увеличением числа потоков $N$ практически пропорционально их количеству, пока $N$ не превышает количества физических ядер процессора. Это говорит о хорошей сильной масштабируемости рассматриваемой параллельной реализации.

\addimghere{perf-threads}{0.75}{Тест масштабируемости OpenMP Intel Xeon Phi 7290 KNL (1.5 Ггц, 72 ядра x 4 Hyper-Threading, 16ГБ кэш MCDRAM)}{perf-threads}

Отметим, что технология Hyper-Threading (для $N>72$) хоть и не значительно, но позволяет дополнительно ускорить исполнение параллельной программы.

\subsection{Сравнение OpenMP и LuNA параллельных реалазиций}
В работе произведено сравнение производительности параллельной программы реализованной средствами OpenMP вручную
и программы автоматически сконструированной системой LuNA для одного узла с общей памятью автоматически(количество фрагментов
равно количеству физических ядер CPU этого узла).

Результаты сравнения показывают, что время вычислений для фрагментированной программы сопоставимо с временем вычислений
программы реализованной средствами OpenMP. Однако количество потребляемой фрагментированной программой памяти значительно выше.

Достоинством фрагментированной программы является то, что она может быть исполнена на
вычислительных системах, в самом общем случае, с гетерогенными узлами.
Тогда как у параллельной программы с ипользованием OpenMP такой возможности нет
(необходимо реализовывать ее аналог, например, с использованием средств MPI).

\subsection{Сравнение с конечно-разностным методом}

Отдельным вопросом интересующим исследователя является вычислительная эффективность спектрально-разностного подхода.
Для этого необходимо при фиксированных параметрах рассматриваемой среды и временном интервале, подобрать количество гармоник таким образом,
чтобы численные решения обоих алгоритмов были эквиваленты.

Для тестов, в однородной среде с источником типа центр давления, расположенном в центре исследуемой среды,
было зафиксировано число шагов по времени равное 1024. Размер расчетной области по $z$ координате варьировался от $2^{11}$ до $2^{13}$.

Численные эксперименты (рис. \ref{mkl-final-k}) показывают, что время работы спектрального алгоритма(непререрывные линии) становится сравнимо со временем работы алгоритма, реализующего конечно-разностный подход(пунктирная линия), при количестве гармоник приблизительно равном 16.

\addimghere{fdm-vs-sdm}{0.75}{Сравнение времени работы спектрально-разностного и конечно-разностного методов для различного числа гармоник}{fdm-vs-sdm}

\clearpage
