\section{Исследование эффективности разработанного программного обеспечения}

В главе производится сравнение параллельной и последовательной программ реализующих,
рассматриваемый в данной работе, спектрально-разностный метод.
Приводятся результаты исследований параллельной программы сгенированной системой LuNA.
Также представленно сравнение времени работы программ реализующих спектрально-разностный алгоритм
и конечно-разностную схему Верье.

\subsection{Сравнение времени работы последовательной и параллельной реализаций}

Время работы спектрально-разностного алгоритма, при фиксированных физических параметрах среды и временном интервале,
зависит от 2 параметров: от размера сетки по $z$ кординате и от количества рассматриваемых гармоник.

Если положить, что количество узлов по $z$ координате равно $N$, а количество рассматриваемых гармоник равно $K$,
то ассимпточеская оценка времени работы последовательного алгоритма составит $O(N\cdot K \cdot log(K))$ для $K=2^p$.

Если рассмотреть идеальную систему с $T$ физическими вычислительными ядрами, то при достаточно большой значении $N$,
ожидаемое ускорение согласно Закону Амдала не превзойдет величины $S = \frac{1}{\frac{T}{N} + \frac{1-\frac{T}{N}}{T}}$

Для эксперимента была взята система с 8 физическими ядрами($T=8$), значения сетки по $z$ варьировались от $2^8$ до $2^{16}$.
Также для того, чтобы показать, что ассимтотическая оценка сложности может быть показательной для оценки сложности алгоритма,
варьировалось число рассматриваемых гармоник (рис. \ref{perf-3-log}).

\addimghere{perf-3-log}{0.75}{Сравнение последовательной и параллельной реализации. Intel Core-i9 (16 X 2300 MHz CPUs) L3 Unified 16384 KiB}{perf-3-log}

В результате распараллеливания удается добиться прироста производительности примерно в 6-7 раз. Тогда как
ожидаемое значение $S$ по закону Амдала составляет 7,5-8 для рассматриваемых сеток. Также из графиков видно, что прирост
производительности для различных значений K(числа рассматриваемых в эксперименте гармоник) не изменяется.

Другим интересным результатом является то, что при достаточно большом количестве рассматриваемых гармоник
наиболее эффективный результат дает комбинация Intel MKL и OpenMP (рис. \ref{mkl-final-k}).

Из графика (рис. \ref{mkl-final-k}) видно, что при количестве гармоник большем чем 128, использование библиотеки Intel MKL
дает выйгрыш производительности, тогда как при относительно маленьком числе гармоник(порядка 32), наблюдается существенное замедление.

\addimghere{mkl-final-k}{0.75}{Сравнение параллельных реализаций с/без использования Intel MKL. Intel Core-i9 (16 X 2300 MHz CPUs) L3 Unified 16384 KiB}{mkl-final-k}

Отдельный интерес представляет тест масштабируемости параллельной реализации с использованием OpenMP (рис. \ref{perf-threads}).
Он показывает, что величина $T(1)/T(N)$, где $T(N)$ - время работы программы для $N$ потоков, а $T(1)$ - время ее последовательного исполнения, растет с увеличением числа потоков $N$ практически пропорционально их количеству, пока $N$ не превышает количества физических ядер процессора. Это говорит о хорошей сильной масштабируемости рассматриваемой параллельной реализации.

\addimghere{perf-threads}{0.75}{Тест масштабируемости OpenMP Intel Xeon Phi 7290 KNL (72 X 1.5 GHz X 4 Hyper-Threading, 16GB MCDRAM)}{perf-threads}

Отметим, что технология Hyper-Threading (для $N>72$) хоть и не значительно, но позволяет дополнительно ускорить исполнение параллельной программы.

\subsection{Сравнение OpenMP и LuNA параллельных реализаций}
В работе произведено сравнение производительности параллельной программы реализованной средствами OpenMP вручную
и программы автоматически сконструированной системой LuNA для одного узла с общей памятью автоматически (количество фрагментов
равно количеству физических ядер CPU этого узла).

Результаты сравнения показывают, что время вычислений для фрагментированной программы (LuNA time),
при фиксированном числе шагов по времени (1024) и количестве гармоник (64),
сопоставимо с временем вычислений программы реализованной средствами OpenMP (OMP time) (таблица \ref{table2}).
Однако количество потребляемой фрагментированной программой памяти (LuNA mem) значительно выше,
чем у программы реализованной срествами OpenMP (OMP mem) (таблица \ref{table3}).
\begin{center}
\begin{table}[h!]
\centering
  \begin{tabular}{|c|c|c|c|}
   \hline
	\textbf{Z} & \textbf{LuNA time, s} &  \textbf{OMP time, s} & \textbf{Luna time / OMP time} \\
	\hline
	8192 & 36.48 & 15.50 & 2.35 \\
	\hline
	4096 & 18.29 & 8.00 & 2.28 \\
	\hline
	2048 & 8.78 & 4.11 & 2.14 \\
	\hline
	1024 & 4.76 & 1.70 & 2.8 \\
  \hline 
  \end{tabular}
  \captionsetup{justification=centering}
  \caption{Сравнение времени работы LuNA и OpenMP реализаций при фиксированных количестве шагов по времени и количестве гармоник. Intel Core-i9 (16 X 2300 MHz CPUs) L3 Unified 16384 KiB}\label{table2}
\end{table}
\end{center}
\begin{center}
\begin{table}[h!]
\centering
  \begin{tabular}{|c|c|c|c|}
   \hline
	\textbf{Z} & \textbf{LuNA mem, GB} & \textbf{OMP mem, GB}  & \textbf{LuNA mem / OMP mem} \\
	\hline
	8192 & 5.87 & 0.05 & 117.4 \\
	\hline
	4096 & 3.07 & 0.02 & 153.5 \\
	\hline
	2048 & 1.37 & 0.01 & 137.0 \\
	\hline
	1024 & 0.51 & 0.01 & 51.0 \\
  \hline 
  \end{tabular}
  \captionsetup{justification=centering}
  \caption{Сравнение потребляемой памяти для LuNA и OpenMP реализаций при фиксированных количестве шагов по времени и количестве гармоник. Intel Core-i9 (16 X 2300 MHz CPUs) L3 Unified 16384 KiB}\label{table3}
\end{table}
\end{center}

Недостатком фрагментированной программы является резкий рост потребляемой памяти, при увеличении шагов по времени.
Это связанно с неоптимальной реализацией асинхронной "сборки мусора" в системе LuNA,
эта проблема может быть частично решена с помощью специальных языковых конструкций - "рекомендаций",
которые позволяют "подсказать" компилятору, что данный фрагмент данных больше не используется, и память занимаемая им может быть освобождена.

Для тестов количество шагов по времени варьировалось с $2^5$ до $2^{12}$, а количество узлов по $z$
и гармоник было зафиксировано (2048 и 64 соответственно) (рис. \ref{luna-mem}).

\addimghere{luna-mem}{0.75}{Сравнение потребления памяти с рекомендациями и без для системы LuNA. Intel Core-i9 (16 X 2300 MHz CPUs) L3 Unified 16384 KiB}{luna-mem}

Достоинством фрагментированной программы является то, что она может быть исполнена на
вычислительных системах, в самом общем случае, с гетерогенными узлами.
Тогда как у параллельной программы с ипользованием OpenMP такой возможности нет
(необходимо реализовывать ее аналог, например, с использованием средств MPI).

\subsection{Сравнение с конечно-разностным методом}

Отдельным вопросом интересующим исследователя является вычислительная эффективность спектрально-разностного подхода (SDM).

Для конечно-разностного метода Верье (FDM) оптимальное количество узлов на длину волны составляет 40 (согласно результатам полученным в работе \cite{vir}).
Для спектрально-разностного метода это количество составляет 5 гармоник на длину волны \cite{mart}.

Для тестов, в однородной среде с источником типа центр давления, расположенном в центре исследуемой среды,
было зафиксировано число шагов по времени равное 2048, размер области по $z$ 8192.
Размер области по $x$ варьировался от $2^9$ до $2^{13}$ узлов. Значения $K$ выбирались согласно рекомендациям описанным выше.

Численные эксперименты (таблица \ref{table}) показывают, что время работы спектрального алгоритма значительно больше,
чем время работы конечно-разностной схемы Верье.

\begin{center}
\begin{table}[h!]
\centering
  %\caption{Сравнение конечно-разностного метода Верье и спектрально-разностного подхода}\label{table}
  \begin{tabular}{|c|c|c|c|c|}
   \hline
	\textbf{K} &  \textbf{SDM time, s} & \textbf{X} & \textbf{FDM time, s} & \textbf{SDM time / FDM time} \\
	\hline
	64 &  61 & 512 & 5.7 & 10.7 \\
	\hline
	128 &  147 & 1024 & 10.9 & 14.7 \\
	\hline
	256 &  407 & 2048 & 22.2 & 18.3 \\
	\hline
	512 &  1777 & 4096 & 48.6 & 36.5 \\
	\hline
	1024 &  5440 & 8192 & 125 & 43.5 \\
  \hline 
  \end{tabular}
  \captionsetup{justification=centering}
  \caption{Сравнение конечно-разностного метода Верье и спектрально-разностного подхода. Intel Xeon Phi 7290 KNL (72 X 1.5 GHz X 4 Hyper-Threading, 16GB MCDRAM)}\label{table}
\end{table}
\end{center}

Достоинством спектрального-разностного алгоритма является то, что при количестве гармоник $K$ и узлов по пространству $N$,
использующихся в реальных численных задачах, он потребляет меньше памяти ($O(N\cdot K)$), чем его конечно-разностный аналог ($O(N^2)$).
Однако для этих же параметров количество операций в спектрально-разностном алгоритме ($O(N\cdot K\cdot log(K))$),
оказывается больше, чем количество операций в алгоритме для конечно-разностной схемы Верье ($O(N^2)$).
Этим фактом объясняется наблюдаемое замедление исполнения. 

Другим интересным результатом является, что при увеличении размера области по $z$ для спектрально-разностного метода, при фиксированном $x$ для конечно-разностной схемы Верье, разница во времени исполнения между этими двумя алгоритмами уменьшается.

Для исследования данного эффекта, было зафиксировано число шагов по времени равное 2048, число гармоник 256, размер области по $x$ равный 2048.
Размер расчетной области по $z$ координате варьировался от $2^{11}$ до $2^{14}$ (таблица \ref{table4}).

\begin{center}
\begin{table}[h!]
\centering
  %\caption{Сравнение конечно-разностного метода Верье и спектрально-разностного подхода}\label{table}
  \begin{tabular}{|c|c|c|c|}
   \hline
	\textbf{Z} &  \textbf{SDM time, s} & \textbf{FDM time, s} & \textbf{SDM time / FDM time} \\
	\hline
	2048 &  111.0 & 5.1 & 21.76 \\
	\hline
	4096 &  211.0 & 10.6 & 19.79 \\
	\hline
	8192 &  407.0 & 22.2 & 18.33 \\
	\hline
	16384 &  800.0 & 48.2 & 16.60 \\
  \hline 
  \end{tabular}
  \captionsetup{justification=centering}
  \caption{Сравнение времени работы спектрально-разностного и конечно-разностного методов для различных значений z. Intel Xeon Phi 7290 KNL (72 X 1.5 GHz X 4 Hyper-Threading, 16GB MCDRAM)}\label{table4}
\end{table}
\end{center}

Более удачной архитектурой для реализации спектрально-разностного алгоритма может стать программируемая логическая схема (ПЛИС).
Время выполнения операций типа сверток (реализованных при помощи БПФ) на таких схемах может быть значительно меньше,
чем время выполнения на стандартных CPU. Например, для 256 точечного алгоритма БПФ время обработки на CPU (Intel Core-i9 (16 X 2300 MHz CPUs) L3 Unified 16384 KiB) составляет величину порядка 2 мс., в то время как аналогичный алгоритм реализованный на ПЛИС выполняется 0.1 мс \cite{ivan}.
Таким образом время исполнения спектрально-разностного алгоритма может быть существенно уменьшено.

\clearpage
