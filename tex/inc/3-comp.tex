\section{Исследование эффективности разработанного программного обеспечения}

В главе производится сравнение параллельной и последовательной программ реализующих,
рассматриваемый в данной работе, спектрально-разностный метод.
Приводятся результаты исследований параллельной программы сгенированной системой LuNA.
Также представленно сравнение времени работы программ реализующих спектрально-разностный алгоритм
и конечно-разностную схему Верье.

\subsection{Сравнение времени работы последовательной и параллельной реализаций}

Время работы спектрально-разностного алгоритма, при фиксированных физических параметрах среды и временном интервале,
зависит от 2 параметров: от размера сетки по $z$ кординате и от количества рассматриваемых гармоник.

Если положить, что количество узлов по $z$ координате равно $N$, а количество рассматриваемых гармоник равно $K$,
то ассимпточеская оценка времени работы последовательного алгоритма составит $O(N\cdot K^2 \cdot log(K))$ для $K=2^p$.

Если рассмотреть идеальную систему с $T$ физическими вычислительными ядрами, то при достаточно большой значении $N$,
ожидаемое ускорение согласно Закону Амдала не превзойдет величины $S = \frac{1}{\frac{T}{N} + \frac{1-\frac{T}{N}}{T}}$

Для эксперимента была взята система с 8 физическими ядрами($T=8$), значения сетки по $z$ варьировались от $2^8$ до $2^{16}$.
Также для того, чтобы показать, что ассимтотическая оценка сложности может быть показательной для оценки сложности алгоритма,
варьировалось число рассматриваемых гармоник (рис. \ref{perf-3-log}).

\addimghere{perf-3-log}{0.75}{Сравнение последовательной и параллельной реализации. Intel Core-i9(8 X 2300 MHz CPUs) L3 Unified 16384 KiB}{perf-3-log}

В результате распараллеливания удается добиться прироста производительности примерно в 6-7 раз. Тогда как
ожидаемое значение $S$ по закону Амдала составляет 7,5-8 для рассматриваемых сеток. Также из графиков видно, что прирост
производительности для различных значений K(числа рассматриваемых в эксперименте гармоник) не изменяется.

Другим интересным результатом является то, что при достаточно большом количестве рассматриваемых гармоник
наиболее эффективный результат дает комбинация Intel MKL и OpenMP (рис. \ref{mkl-final-k}).

Из графика (рис. \ref{mkl-final-k}) видно, что при количестве гармоник большем чем 128, использование библиотеки Intel MKL
дает выйгрыш производительности, тогда как при относительно маленьком числе гармоник(порядка 32), наблюдается существенное замедление.

\addimghere{mkl-final-k}{0.75}{Сравнение параллельных реализаций с/без использования Intel MKL. Intel Core-i9(8 X 2300 MHz CPUs) L3 Unified 16384 KiB}{mkl-final-k}

Отдельный интерес представляет тест масштабируемости параллельной реализации с использованием OpenMP (рис. \ref{perf-threads}).
Он показывает, что величина $T(1)/T(N)$, где $T(N)$ - время работы программы для $N$ потоков, а $T(1)$ - время ее последовательного исполнения, растет с увеличением числа потоков $N$ практически пропорционально их количеству, пока $N$ не превышает количества физических ядер процессора. Это говорит о хорошей сильной масштабируемости рассматриваемой параллельной реализации.

\addimghere{perf-threads}{0.75}{Тест масштабируемости OpenMP Intel Xeon Phi 7290 KNL (1.5 Ггц, 72 ядра x 4 Hyper-Threading, 16ГБ кэш MCDRAM)}{perf-threads}

Отметим, что технология Hyper-Threading (для $N>72$) хоть и не значительно, но позволяет дополнительно ускорить исполнение параллельной программы.

\subsection{Сравнение OpenMP и LuNA параллельных реалазиций}
В работе произведено сравнение производительности параллельной программы реализованной средствами OpenMP вручную
и программы автоматически сконструированной системой LuNA для одного узла с общей памятью автоматически(количество фрагментов
равно количеству физических ядер CPU этого узла).

Результаты сравнения показывают, что время вычислений для фрагментированной программы(LuNA time),
при фиксированном числе шагов по времени(1024) и количестве гармоник(64),
сопоставимо с временем вычислений программы реализованной средствами OpenMP(OMP time) (таблица \ref{table2}).
Однако количество потребляемой фрагментированной программой памяти(LuNA mem) значительно выше,
чем у программы реализованной срествами OpenMP(OMP mem) (таблица \ref{table3}).
\begin{center}
\begin{table}[h!]
\centering
  \begin{tabular}{|c|c|c|c|}
   \hline
	\textbf{Z} & \textbf{LuNA time, s} &  \textbf{OMP time, s} & \textbf{Luna time / OMP time} \\
	\hline
	8192 & 36.48 & 15.50 & 2.35 \\
	\hline
	4096 & 18.29 & 8.00 & 2.28 \\
	\hline
	2048 & 8.78 & 4.11 & 2.14 \\
	\hline
	1024 & 4.76 & 1.70 & 2.8 \\
  \hline 
  \end{tabular}
  \captionsetup{justification=centering}
  \caption{Сравнение времени работы LuNA и OpenMP реализаций при количестве шагов по времени и количестве гармоник. Intel Core-i9(8 X 2300 MHz CPUs) L3 Unified 16384 KiB}\label{table2}
\end{table}
\end{center}
\begin{center}
\begin{table}[h!]
\centering
  \begin{tabular}{|c|c|c|c|}
   \hline
	\textbf{Z} & \textbf{LuNA mem, GB} & \textbf{OMP mem, GB}  & \textbf{LuNA mem / OMP mem} \\
	\hline
	8192 & 5.87 & 0.05 & 117.4 \\
	\hline
	4096 & 3.07 & 0.02 & 153.5 \\
	\hline
	2048 & 1.37 & 0.01 & 137.0 \\
	\hline
	1024 & 0.51 & 0.01 & 51.0 \\
  \hline 
  \end{tabular}
  \captionsetup{justification=centering}
  \caption{Сравнение потребляемой памяти для LuNA и OpenMP реализаций при количестве шагов по времени равном 1024. Intel Core-i9(8 X 2300 MHz CPUs) L3 Unified 16384 KiB}\label{table3}
\end{table}
\end{center}

Недостатком фрагментированной программы является резкий рост потребляемой памяти, при увеличении шагов по времени.
Это связанно с неоптимальной реализацией асинхронной "сборки мусора" в системе LuNA,
эта проблема может быть частично решена с помощью специальных языковых конструкций - "рекомендаций",
которые позволяют "подсказать" компилятору, что данный фрагмент данных больше не используется, и память занимаемая им может быть освобождена.

Для тестов количество шагов по времени варьировалось с $2^5$ до $2^{12}$, а количество узлов по $z$
и гармоник было зафиксировано(2048 и 64 соответственно) (рис. \ref{luna-mem}).

\addimghere{luna-mem}{0.75}{Сравнение потребления памяти с рекомендациями и без для системы LuNA. Intel Core-i9(8 X 2300 MHz CPUs) L3 Unified 16384 KiB}{luna-mem}

Достоинством фрагментированной программы является то, что она может быть исполнена на
вычислительных системах, в самом общем случае, с гетерогенными узлами.
Тогда как у параллельной программы с ипользованием OpenMP такой возможности нет
(необходимо реализовывать ее аналог, например, с использованием средств MPI).

\subsection{Сравнение с конечно-разностным методом}

Отдельным вопросом интересующим исследователя является вычислительная эффективность спектрально-разностного подхода(SDM).
Для этого необходимо при фиксированных параметрах рассматриваемой среды и временном интервале, подобрать количество гармоник таким образом,
чтобы численные решения обоих алгоритмов были эквиваленты.

Для конечно-разностного метода Верье(FDM) оптимальное количество узлов на длину волны составляет 40(согласно результатам полученным в работе \cite{vir}).
Для спектрально-разностного метода выбрано 5 точек на рассматриваемую длину волны \cite{mart}.

Для тестов, в однородной среде с источником типа центр давления, расположенном в центре исследуемой среды,
было зафиксировано число шагов по времени равное 2048, размер области по $z$ 8192.
Размер области по $x$ варьировался от $2^9$ до $2^{13}$ узлов. Значения $K$ выбирались согласно рекомендациям описанным выше.

Численные эксперименты (таблица \ref{table}) показывают, что время работы спектрального алгоритма приблизительно в 20 раз больше,
чем время работы конечно-разностного Верье.
Однако заметим, что при использовании программируемых логических схем (ПЛИС), выполняющих БПФ за минимальное время, время
исполнения спектрально-разностного алгоритма может стать сравнимым с временем выполнения его конечно-разностного аналога \cite{ivan}.

\begin{center}
\begin{table}[h!]
\centering
  %\caption{Сравнение конечно-разностного метода Верье и спектрально-разностного подхода}\label{table}
  \begin{tabular}{|c|c|c|c|}
   \hline
	\textbf{K} &  \textbf{SDM time, s} & \textbf{X} & \textbf{FDM time, s} \\
	\hline
	64 &  61 & 512 & 5.7 \\
	\hline
	128 &  147 & 1024 & 10.9 \\
	\hline
	256 &  407 & 2048 & 22.2 \\
	\hline
	512 &  1777 & 4096 & 48.6 \\
	\hline
	1024 &  5440 & 8192 & 125 \\
  \hline 
  \end{tabular}
  \captionsetup{justification=centering}
  \caption{Сравнение конечно-разностного метода Верье и спектрально-разностного подхода. Intel Xeon Phi 7290 KNL (1.5 Ггц, 72 ядра x 4 Hyper-Threading, 16ГБ кэш MCDRAM)}\label{table}
\end{table}
\end{center}

Другим интересным результатом является, что при увеличении размера области по $z$ для спектрально-разностного метода, при фиксированном $x$ для конечно-разностной схемы Верье, разница во времени исполнения между этими двумя алгоритмами уменьшается.

Для исследования данного эффекта, было зафиксировано число шагов по времени равное 2048, число гармоник 256, размер области по $x$ равный 2048.
Размер расчетной области по $z$ координате варьировался от $2^{11}$ до $2^{14}$ (рис. \ref{speed-z}).

\addimghere{speed-z}{0.75}{Сравнение времени работы спектрально-разностного и конечно-разностного методов для различных значений z. Intel Xeon Phi 7290 KNL (1.5 Ггц, 72 ядра x 4 Hyper-Threading, 16ГБ кэш MCDRAM)}{speed-z}

\clearpage
